.. image:: docs/bitpacker.svg
    :width: 10 %
.. image:: https://codecov.io/gh/jonasblixt/bpak/branch/master/graph/badge.svg
  :target: https://codecov.io/gh/jonasblixt/bpak
.. image:: https://travis-ci.org/jonasblixt/bpak.svg?branch=master
    :target: https://travis-ci.org/jonasblixt/bpak
.. image:: https://scan.coverity.com/projects/20419/badge.svg
    :target: https://scan.coverity.com/projects/jonasblixt-bpak

------------
Introduction
------------

Bitpacker or bpak for short is a tool and library for creating firmware archives
that can be cryptographically signed, support custom metadata and enable
advanced update schemes. Bitpacker is primarily designed for embedded systems.

Embedded systems are often composed of several software components, for example:
bootloader, kernel, file systems, device configuration, third party applications,
etc. It is common to have many different formats and tools for the various
components.

One of the main goals with bitpacker is to reduce the number of tools and
formats required to manage these components.

-------------
Core concepts
-------------

A bpak archive is composed of a 4kByte header and parts. A part is any kind
of data. The header contains a list of parts, a list of meta data and details
about how the package should be hashed and signed. 2kBytes are reserved for 
actual metadata within the header.

The metadata header encodes and id, size and offset within the metadata block
of the header. An optional part-reference can be populated if the metadata
belongs to a specific part.

Bitpacker id's are generated by computing a crc32 checksum of a character string.
For example the package identifier type 'bpak-package', when translated using
the bpak_id-function results in bpak_id('bpak-package') = 0xfb2f1f3f.

To facilitate efficient over-the-air updates a bpak file can be encoded for
transport. In transport some or all parts are encoded, typically using the
bsdiff algorithm.

Bitpacker supports two different signing schemes, one where the private key is
available on disk which is appropriate for un-controlled development keys but
makes life easier for day-to-day development. The second way is to export a
binary hash that can be signed in a controlled environment. Bitpacker supports
retrofitting DER formatted signatures, which, for example, is what openssl can
produce. This way an approved release candidate can be re-signed with
production keys without rebuilding all the artefacts that make up a bpak archive.

-----------
Limitations
-----------

Bitpacker is not a complete package management system, it provides some
necessary low level primitives that can enable such a system. If you choose
to use it there is likely a lot of integration work that needs to be done
before it is useful in any sense of the word.

The library and format does not specify how to install a package and therefore left as an implementation detail.

Bitpacker is new and not really supported by any other projects except the
punchboot bootloader (https://github.com/jonasblixt/punchboot)

The library does not include any cryptographic API or functionality, it only
comes with a structure for storing signatures and some concepts to enable
signature verification and key management.

------------------------
Well known metadata id's
------------------------

==========  =================          ===========
ID          Encoding                   Description
==========  =================          ===========
0xfb2f1f3f  UUID                       bpak-package, Package identifier type
0x7da19399  uint32                     bpak-key-id, Identifier of key used for signing
0x106c13a7  uint32                     bpak-key-store, Identifier of key-store
0xe5679b94  uint8[]                    bpak-signature, Octet-stream that contains the DER encoded signature
0x9e5e4955  uint32                     bpak-key-mask, Encodes a security life cycle bit mask
0x9a5bab69  char[]                     bpak-version, Version string
0x0ba87349  <UUID, char>               bpak-dependency, Dependency tuple, UUID reference to another package and text string expressing constraints
0x2d44bbfb  <uint32, uint32>           bpak-transport, Transport medadata contains int32 pair that describes which encoder and decoder should be used for transport
==========  =================          ===========

-----------------------------
Built in transport algorithms
-----------------------------

==========  =================  ===========
ID          Name               Description
==========  =================  ===========
0xb5bcc58f  merkle-generate    This decoder builds a merkle hash tree out of part data
0x57004cd0  remove-data        Encoder that strips data from a part during transport encoding
0x9f7aacf9  bsdiff             Encoder that creates a binary diff of a part given some other original part
0xb5964388  bspatch            Decoder that reverses the operation of bspatch
0xe31722a6  heatshrink-encode  Heatshrink compression algorithm
0x5f9bc012  heatshrink-decode  Heatshrink decompression algorithm
==========  =================  ===========

----------
Versioning
----------

The bitpacker tool and library uses semver 2.0.0 versioning

-----------------------
Building and installing
-----------------------

The library has no external dependencies and the tool only depends on the c
library and the bpak library.

The 'autoconf-archive' package must be installed before running autoreconf.

Build library and tool::

    $ autoreconf -fi
    $ ./configure
    $ make
    $ sudo make install

Running tests::

    $ ./configure --enable-code-coverage
    $ make && make check

-------------
Basic example
-------------

In the simplest use-case for bitpacker the archive can be viewed as a container
format for other binaries with metadata on sizes and offsets of the parts it 
contains.

Create an empty archive::

    $ bpak create demo.bpak
    $ bpak show demo.bpak
    BPAK File: demo.bpak

    Hash:      sha256
    Signature: prime256v1

    Metadata:
        ID         Size   Meta ID              Part Ref   Data

    Parts:
        ID         Size         Z-pad  Flags          Transport Size

    Hash: b4ea1989f2e8a8be290bf819644e41fcc9631b62ab0c21b6355e3cfd50fb44eb

Add two parts to the archive::

    $ bpak add demo.bpak --part part1 --from-file file_one
    $ bpak add demo.bpak --part part2 --from-file file_two
    $ bpak show demo.bpak

    BPAK File: demo.bpak

    Hash:      sha256
    Signature: prime256v1

    Metadata:
        ID         Size   Meta ID              Part Ref   Data

    Parts:
        ID         Size         Z-pad  Flags          Transport Size
        37b0705f   4857856      0      --------       4857856
        aeb921e5   4907008      0      --------       4907008

    Hash: c41a2bf1096628f9d81d2e52318e591a7519182e2c17ab0d0f3790c63f656a5c

The archive now contains the two files and some metadata that describes how
the files are stored in the archive. 


----------------
Advanced example
----------------

Create an empty archive::

    $ bpak create demo.bpak
    $ bpak show demo.bpak
    BPAK File: demo.bpak

    Hash:      sha256
    Signature: prime256v1

    Metadata:
        ID         Size   Meta ID              Part Ref   Data

    Parts:
        ID         Size         Z-pad  Flags          Transport Size

    Hash: b4ea1989f2e8a8be290bf819644e41fcc9631b62ab0c21b6355e3cfd50fb44eb

The default hashing and signing algorithm is sha256 and elliptic curve prime256v1
signature format.

Adding a package type identifier::

    $ bpak add demo.bpak --meta bpak-package \
                         --from-string "74a53c6d-3556-49f5-a9cd-481ebf22baab" \
                         --encoder uuid

    $ bpak show demo.bpak
    BPAK File: demo.bpak

    Hash:      sha256
    Signature: prime256v1

    Metadata:
        ID         Size   Meta ID              Part Ref   Data
        fb2f1f3f   16     bpak-package                    74a53c6d-3556-49f5-a9cd-481ebf22baab

    Parts:
        ID         Size         Z-pad  Flags          Transport Size

    Hash: 0e6e976e6137b1e8e38546773c9e257495053fd42d397e0f958cdd39786cddca

Bitpacker supports a few ways to encode metadata, in the example above we're
using the uuid encoder to translate the uuid string into the 16 byte 'raw' uuid.

Adding some real data::

    $ bpak add demo.bpak --part fs \
                         --from-file demo_filesystem.squash \
                         --set-flag dont-hash \
                         --encoder merkle
    $ bpak show demo.bpak
    BPAK File: demo.bpak

    Hash:      sha256
    Signature: prime256v1

    Metadata:
        ID         Size   Meta ID              Part Ref   Data
        fb2f1f3f   16     bpak-package                    74a53c6d-3556-49f5-a9cd-481ebf22baab
        7c9b2f93   32     merkle-salt          faabeca7   92c1b824ade773441e2f57698dc6bb6937f2ed14b9deea702c8520319c79b829
        e68fc9be   32     merkle-root-hash     faabeca7   89acacdf13051c2f5058c13453f7f812fd25164a09e4a0cae30d8c4bb846f81d

    Parts:
        ID         Size         Z-pad  Flags          Transport Size
        faabeca7   4857856      0      h-------       4857856
        77fadb17   45056        0      h-------       45056

    Hash: aa6bdefc5e1a95dcfe6211fbbc6d1a68984d99c2c4fa9d0ed074c4f520b40046
 
In this operation we added a squashfs filesystem image with the merkle encoder.
This creates an additional part that contains a merkle hash tree, which is
compatible with the dm-verity device mapper target in the linux kernel.

Another result of the merkle encoder are two additional metadata fields,
the 'merkle-root-hash' and the 'merkle-salt'. The root hash meta as the name
suggests is the top most hash in the hash tree.

In this archive the parts are not hashed because we only need to ensure that
the salt and root hash are not compromised.

Add transport encoding information::

    $ bpak transport demo.bpak --add --part fs \
                               --encoder bsdiff \
                               --decoder bspatch

    $ bpak transport demo.bpak --add --part fs-hash-tree \
                               --encoder remove-data \
                               --decoder merkle-generate
    $ bpak show demo.bpak
    BPAK File: demo.bpak

    Hash:      sha256
    Signature: prime256v1

    Metadata:
        ID         Size   Meta ID              Part Ref   Data
        fb2f1f3f   16     bpak-package                    74a53c6d-3556-49f5-a9cd-481ebf22baab
        7c9b2f93   32     merkle-salt          faabeca7   92c1b824ade773441e2f57698dc6bb6937f2ed14b9deea702c8520319c79b829
        e68fc9be   32     merkle-root-hash     faabeca7   89acacdf13051c2f5058c13453f7f812fd25164a09e4a0cae30d8c4bb846f81d
        2d44bbfb   32     bpak-transport       faabeca7   Encode: 9f7aacf9, Decode: b5964388
        2d44bbfb   32     bpak-transport       77fadb17   Encode: 57004cd0, Decode: b5bcc58f

    Parts:
        ID         Size         Z-pad  Flags          Transport Size
        faabeca7   4857856      0      h-------       4857856
        77fadb17   45056        0      h-------       45056

    Hash: cadbd6ed13046bc40da6a522ae45df6e48b5d3fea4b124e9ab9c4c7fcad6243f
 
The archive now contains information on how the two parts should be encoded
for transport and how they should be decoded when installing the archive. In
this example the hash-tree is completely removed because it can be generated
using the data in the 'fs' part and the 'merkle-salt' meta, and then be verified
by comparing the 'merkle-root-hash' meta with the generated root hash.

The 'fs' part is encoded using the bsdiff algorithm, which when the actual
encoding is going to be done requires some reference data.

Signing the package::

    $ bpak sign demo.bpak --key prime256v1-key-pair.pem \
                          --key-id demo-key-id \
                          --key-store demo-key-store

    $ bpak show demo.bpak
    BPAK File: demo.bpak

    Hash:      sha256
    Signature: prime256v1

    Metadata:
        ID         Size   Meta ID              Part Ref   Data
        fb2f1f3f   16     bpak-package                    74a53c6d-3556-49f5-a9cd-481ebf22baab
        7c9b2f93   32     merkle-salt          faabeca7   92c1b824ade773441e2f57698dc6bb6937f2ed14b9deea702c8520319c79b829
        e68fc9be   32     merkle-root-hash     faabeca7   89acacdf13051c2f5058c13453f7f812fd25164a09e4a0cae30d8c4bb846f81d
        2d44bbfb   32     bpak-transport       faabeca7   Encode: 9f7aacf9, Decode: b5964388
        2d44bbfb   32     bpak-transport       77fadb17   Encode: 57004cd0, Decode: b5bcc58f
        7da19399   4      bpak-key-id                     36edee98
        106c13a7   4      bpak-key-store                  f45573db
        e5679b94   70     bpak-signature

    Parts:
        ID         Size         Z-pad  Flags          Transport Size
        faabeca7   4857856      0      h-------       4857856
        77fadb17   45056        0      h-------       45056
    
    Hash: 86712dfc65614c56d1fcb4fbcb0b2775ce5dacc84cc7c9a8248d2378101b6ee4

The signing operation adds three meta-data fields. The bpak-key-id that represents
some kind of identification of the key that was used for signing and the bpak-key-store
which is optionally used as and identifier of groups of verification keys.

And of course the actual signature in 'bpak-signature'

Verifying the package::

    $ bpak verify demo.bpak --key prime256v1-public-key.der
    Verification OK

Encoding the package for transport::

    $ bpak transport demo.bpak --encode --origin demo_old.bpak
    $ bpak show demo.bpak
    BPAK File: demo.bpak

    Hash:      sha256
    Signature: prime256v1

    Metadata:
        ID         Size   Meta ID              Part Ref   Data
        fb2f1f3f   16     bpak-package                    74a53c6d-3556-49f5-a9cd-481ebf22baab
        7c9b2f93   32     merkle-salt          faabeca7   6e23bf2f6fc7c473b68b4a6e48927e1751cf100ff7f1ff4119b23559fb824147
        e68fc9be   32     merkle-root-hash     faabeca7   e26e259011cbf2b7073201f2eeafc7b8ca98512c91a7338b06119c9e137fec9c
        2d44bbfb   32     bpak-transport       77fadb17   Encode: 57004cd0, Decode: b5bcc58f
        2d44bbfb   32     bpak-transport       faabeca7   Encode: 9f7aacf9, Decode: b5964388
        7da19399   4      bpak-key-id                     36edee98
        106c13a7   4      bpak-key-store                  f45573db
        e5679b94   70     bpak-signature

    Parts:
        ID         Size         Z-pad  Flags          Transport Size
        faabeca7   4907008      0      hT------       114562
        77fadb17   45056        0      hT------       0

    Hash: a649eb0532f848f34116deed81140feb5a1f4a221f964231c83216b6cf8896dd

The demo.bpak is now transport encoded. Not the additional 'T' flag which
indicates that a part is transport encoded. The new archive size is now the
sum of the sizes in the 'Transport Size' column.

------------------------
Advanced signing example
------------------------

A not so un-common development flow is working on development releases that
after some iteration turn in to release candidates. The rc's pass through a
number of test steps and eventually a release candidate is considered to be
acceptable for release to production/customer.

At this point it's often desirable to not rebuild the artefacts since it would
incur another suite of testing before it can be released. To enable a flow
where release candidates can be used directly bitpacker supports re-signing.


Extracting the hash in binary form::

    $ bpak show demo.bpak --hash > hash.bin

Signing the hash using openssl::

    $ cat hash.bin | openssl pkeyutl \
                          -sign -inkey prime256v1-key-pair.pem \
                          -keyform PEM > signature.bin

Overwrite the current signature with the openssl generated one::

    $ bpak sign demo.bpak --signature signature.bin \
                          --key-id new-demo-key \
                          --key-store demo-keystore

This enables a signing process with sensitive keys to be de-coupled from the
normal build environment and tools. The signing environment is usually backed
by a HSM where the sensitive keys are stored.

---------------
Comparing files
---------------

Compare files::

    $ bpak compare vA.bpak vB.bpak
    BPAK comparison between:
    1: 'vA.bpak'
    2: 'vB.bpak'

    =   : No differance
    +   : Exists in file 2 but not in file 1
    -   : Exists in file 1 but not in file 2
    *   : Exists in both but data differs

    Metadata:
        ID         Size   Meta ID              Data
    =   fb2f1f3f   16     bpak-package         0888b0fa-9c48-4524-9845-06a641b61edd
    *   79c3b7b4   16
    =   2d44bbfb   32     bpak-transport       Encode: 9f7aacf9, Decode: b5964388
    =   2d44bbfb   32     bpak-transport       Encode: 57004cd0, Decode: b5bcc58f
    =   7c9b2f93   32     merkle-salt          7691130fef9adf5704e702261b151833a176f66c667cad0dc1fb436d7e52707c
    *   e68fc9be   32     merkle-root-hash     7a13e732655cb358779a21ca5fef5b2d6e1052ac791668679f5924f66362a1a1
    =   7da19399   4      bpak-key-id          a90f9680
    =   106c13a7   4      bpak-key-store       365f2120
    *   e5679b94   72     bpak-signature

    Parts:
        ID         Size         Z-pad  Flags          Transport Size
    *   faabeca7   4194304      0      h-------       4194304
    *   77fadb17   36864        0      h-------       36864


-------------
C API Example
-------------

.. code-block:: c

    #include <stdio.h>
    #include <bpak/bpak.h>

    int main(int argc, char **argv)
    {
        const char *filename = "a-1.0.0.bpak";
        FILE *fp = NULL;
        struct bpak_header header;
        int rc;

        printf("Reading '%s'...\n", filename);
        fp = fopen(filename, "r");
        
        if (fread(&header, sizeof(header), 1, fp) != 1)
        {
            printf("Error: Could not read header\n");
            rc = -1;
            goto err_out_close;
        }

        rc = bpak_valid_header(&header);

        if (rc != BPAK_OK)
        {
            printf("Error: Invalid header\n");
            goto err_out_close;
        }

        bpak_foreach_meta(&header, m)
        {
            if (!m->id)
                break;
            printf("Found metadata %x, size: %i bytes, offset: %i\n",
                        m->id, m->size, m->offset);
        }

    err_out_close:
        fclose(fp);
        return rc;
    }

This example opens a bpak file and iterates over the metadata.

Build and run::

    $ gcc c_example -o c_example -lbpak
    $ ./c_example
    Reading 'a-1.0.0.bpak'...
    Found metadata fb2f1f3f, size: 16 bytes, offset: 0
    Found metadata 9a5bab69, size: 6 bytes, offset: 16
    Found metadata ba87349, size: 30 bytes, offset: 24
