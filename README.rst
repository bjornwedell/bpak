.. image:: docs/bitpacker.svg
    :width: 10 %
.. image:: https://codecov.io/gh/jonasblixt/bpak/branch/master/graph/badge.svg
  :target: https://codecov.io/gh/jonasblixt/bpak
.. image:: https://travis-ci.org/jonasblixt/bpak.svg?branch=master
    :target: https://travis-ci.org/jonasblixt/bpak
.. image:: https://scan.coverity.com/projects/20419/badge.svg
    :target: https://scan.coverity.com/projects/jonasblixt-bpak

------------
Introduction
------------

Bitpacker or bpak for short is a tool and library for creating firmware archives
that can be cryptographically signed, support custom metadata and enable
advanced update schemes. Bitpacker is primarly designed for embedded systems.

Embedded systems are often composed of several software components, for example:
bootloader, kernel, filesystems, device configuration, third party applications,
etc. It is common to have many different formats and tools for the various
components.

One of the main goals with bitpacker is to reduce the number of tools and
formats required to manage these components.

-------------
Core concepts
-------------

A bpak archive is composed of a 4kByte header and parts. A part is any kind
of data. The header contains a list of parts, a list of meta data and details
about how the package should be hash'ed and signed. 2kBytes are reserved for 
actual metadata within the header.

The metadata header encodes and id, size and offset within the metadata block
of the header. An optional part-reference can be populated if the metadata
belongs to a specific part.

Bitpacker id's are generated by computing a crc32 checksum of a character string.
For example the package identifier type 'bpak-package', when translated using
the bpak_id-function results in bpak_id('bpak-package') = 0xfb2f1f3f.

To facilitate efficient over-the-air updates a bpak file can be encoded for
transport. In transport some or all parts are encoded, typically using the
bsdiff algorithm.

Bitpacker supports two different signing schemes, one where the private key is
available on disk which is appropriate for un-controlled development keys but
makes life easier for day-to-day development. The second way is to export a
binary hash that can be signed in a controlled environment. Bitpacker supports
retrofitting DER formatted signatures, which, for example, is what openssl can
produce. This way an approved release candidate can be re-signed with
production keys without rebuilding all the artifacts that make up a bpak archive.

TODO: Key-store

TODO: SLC

------------------------
Well known metadata id's
------------------------

ID          Encoding          Description
==========  ========          ===========
0xfb2f1f3f  UUID              bpak-package, Package identifier type
0x7da19399  uint32            bpak-key-id, Identifier of key used for signing
0x106c13a7  uint32            bpak-key-store, Identifier of key-store
0xe5679b94  uint8[]           bpak-signature, Octet-stream that contains the DER encoded signature
0x9e5e4955  uint32            bpak-key-mask, Encodes a security life cycle bit mask
0x9a5bab69  char[]            bpak-version, Version string
0x0ba87349  <UUID, char>      bpak-dependency, Dependency tuple, UUID reference to another package and text string expressing constraints
0x2d44bbfb  <uint32, uint32>  bpak-transport, Transport medadata contains int32 pair that describes which encoder and decoder should be used for transport

--------------
System example
--------------

-----------
Limitations
-----------


----------
Versioning
----------

Bitpacker uses semver 2.0.0


-------------
Example usage
-------------
